package Exploit.org;

import javax.swing.*;
import java.util.LinkedList;
import java.util.ListIterator;

public class Playlist {
    private String playListName;
    private final LinkedList<Track> playlist = new LinkedList<>();

    public Playlist(String playListName) {
        this.playListName = playListName;
    }

    public void setPlayListName(String playListName) {
        this.playListName = playListName;
    }

    public String getPlayListName() {
        return playListName;
    }

    public LinkedList<Track> getPlaylist() {
        return playlist;
    }

    private String displayDialogBox(String[] options, String message) {
        Icon icon = new ImageIcon("src/Exploit/org/TrackStore/WaveFX.png");
        return (String) JOptionPane.showInputDialog(null,
                message,
                "WaveFXâ„¢",
                JOptionPane.INFORMATION_MESSAGE,
                icon,
                options,
                null);
    }

    public boolean renamePlaylist() {
        String response = this.displayDialogBox(null, "Enter a new name for the Playlist : ");
        if (response == null) {
            return false;
        }
        this.setPlayListName(response);
        return true;
    }

    private void promptAlert() {
        JOptionPane.showMessageDialog(null, "            List is empty !",
                "WaveFX", JOptionPane.WARNING_MESSAGE);
    }

    public boolean playThisPlaylist() {
        ListIterator<Track> playListIterator = this.playlist.listIterator();
        int flag;
        boolean isGoingForward = true;
        if (playListIterator.hasNext()) {
            flag = playListIterator.next().waveFxPlayer();
        } else {
            this.promptAlert();
            return false;
        }
        while (flag != 0) {
            if (flag == 1) {
                if (isGoingForward) {
                    if (playListIterator.hasPrevious()) {
                        playListIterator.previous();
                    }
                    isGoingForward = false;
                }
                if (playListIterator.hasPrevious()) {
                    flag = playListIterator.previous().waveFxPlayer();
                } else {
                    //This is the start of the list or Head element of the linked list.
                    flag = playListIterator.next().waveFxPlayer();
                }
            }

            if (flag == 5) {
                if (!isGoingForward) {
                    if (playListIterator.hasNext()) {
                        playListIterator.next();
                    }
                    isGoingForward = true;
                }
                if (playListIterator.hasNext()) {
                    flag = playListIterator.next().waveFxPlayer();
                } else {
                    //This is the End of the list.
                    flag = playListIterator.previous().waveFxPlayer();
                }
            }
            if (flag == 0) {
                return true;
            }
        }
        return false;
    }

    public boolean playTrackFromPlaylist() {
        ListIterator<Track> playListIterator = this.playlist.listIterator();
        if (!playListIterator.hasNext()) {
            this.promptAlert();
            return false;
        }
        String response = this.displayDialogBox(this.trackArrayList(), "Select track from Playlist to Play : ");
        if (response == null) {
            return false;
        }
        while (playListIterator.hasNext()) {
            if (playListIterator.next().getTrackName().equals(response)) {
                int flag = playListIterator.previous().waveFxPlayer();
                if (flag == 1 || flag == 5) {
                    this.playThisPlaylist();
                }
                return true;
            }
        }
        return false;
    }

    private String[] trackArrayList() {
        String[] trackListArray = new String[this.playlist.size()];
        ListIterator<Track> playListIterator = this.playlist.listIterator();
        for (int i = 0; i < this.playlist.size(); i++) {
            trackListArray[i] = playListIterator.next().getTrackName();
        }
        return trackListArray;
    }

    public boolean removeTrackFromPlaylist() {
        ListIterator<Track> playListIterator = this.playlist.listIterator();
        String response = this.displayDialogBox(this.trackArrayList(), "Select track to remove from Playlist : ");
        if (response == null) {
            return false;
        }
        while (playListIterator.hasNext()) {
            if (playListIterator.next().getTrackName().equals(response)) {
                playListIterator.remove();
                return true;
            }
        }
        return false;
    }

    public boolean renameTrackFromPlaylist() {
        ListIterator<Track> playListIterator = this.playlist.listIterator();
        String response = this.displayDialogBox(this.trackArrayList(), "Select track to rename : ");
        if (response == null) {
            return false;
        }
        while (playListIterator.hasNext()) {
            if (playListIterator.next().getTrackName().equals(response)) {
                playListIterator.previous().renameTheTrack();
            }
        }
        return false;
    }

    public boolean playListDriverCode() {
        String[] options = {"Display PlayList's track", "Play", "Rename Playlist", "Rename PlayList's track", "Remove PlayList's track"};
        String response = this.displayDialogBox(options, "Select operation to perform : ");
        if (!(response == null)) {
            switch (response) {
                case "Display PlayList's track":
                    return this.playTrackFromPlaylist();
                case "Play":
                    return this.playThisPlaylist();
                case "Rename Playlist":
                    return this.renamePlaylist();
                case "Rename PlayList's track":
                    return this.renameTrackFromPlaylist();
                case "Remove PlayList's track":
                    return this.removeTrackFromPlaylist();
            }
        }
        return false;
    }
}
